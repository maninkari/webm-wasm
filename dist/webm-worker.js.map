{"version":3,"file":"webm-worker.js","sources":["webm-wasm.js","../src/worker/webm-worker.js","../src/worker/defaults.js"],"sourcesContent":["\nvar Module = (function() {\n  var _scriptDir = import.meta.url;\n  return (\nfunction(Module) {\n  Module = Module || {};\n\n// Copyright 2010 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n\"use strict\";\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {};\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = function(status, toThrow) {\n  throw toThrow;\n};\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_HAS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\nENVIRONMENT_IS_WEB = typeof window === 'object';\nENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n// A web environment like Electron.js can have Node enabled, so we must\n// distinguish between Node-enabled environments and Node environments per se.\n// This will allow the former to do things like mount NODEFS.\n// Extended check using process.versions fixes issue #8816.\n// (Also makes redundant the original check that 'require' is a function.)\nENVIRONMENT_HAS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';\nENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n\n\n// Three configurations we can be running in:\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\n\n\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar read_,\n    readAsync,\n    readBinary,\n    setWindowTitle;\n\nif (ENVIRONMENT_IS_NODE) {\n  scriptDirectory = __dirname + '/';\n\n  // Expose functionality in the same simple way that the shells work\n  // Note that we pollute the global namespace here, otherwise we break in node\n  var nodeFS;\n  var nodePath;\n\n  read_ = function shell_read(filename, binary) {\n    var ret;\n      if (!nodeFS) nodeFS = require('fs');\n      if (!nodePath) nodePath = require('path');\n      filename = nodePath['normalize'](filename);\n      ret = nodeFS['readFileSync'](filename);\n    return binary ? ret : ret.toString();\n  };\n\n  readBinary = function readBinary(filename) {\n    var ret = read_(filename, true);\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n    assert(ret.buffer);\n    return ret;\n  };\n\n  if (process['argv'].length > 1) {\n    thisProgram = process['argv'][1].replace(/\\\\/g, '/');\n  }\n\n  arguments_ = process['argv'].slice(2);\n\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n  process['on']('uncaughtException', function(ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n\n  process['on']('unhandledRejection', abort);\n\n  quit_ = function(status) {\n    process['exit'](status);\n  };\n\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\n} else\nif (ENVIRONMENT_IS_SHELL) {\n\n\n  if (typeof read != 'undefined') {\n    read_ = function shell_read(f) {\n      return read(f);\n    };\n  }\n\n  readBinary = function readBinary(f) {\n    var data;\n    if (typeof readbuffer === 'function') {\n      return new Uint8Array(readbuffer(f));\n    }\n    data = read(f, 'binary');\n    assert(typeof data === 'object');\n    return data;\n  };\n\n  if (typeof scriptArgs != 'undefined') {\n    arguments_ = scriptArgs;\n  } else if (typeof arguments != 'undefined') {\n    arguments_ = arguments;\n  }\n\n  if (typeof quit === 'function') {\n    quit_ = function(status) {\n      quit(status);\n    };\n  }\n\n  if (typeof print !== 'undefined') {\n    // Prefer to use print/printErr where they exist, as they usually work better.\n    if (typeof console === 'undefined') console = {};\n    console.log = print;\n    console.warn = console.error = typeof printErr !== 'undefined' ? printErr : print;\n  }\n} else\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript\n  // is gone, so we saved it, and we use it here instead of any other info.\n  if (_scriptDir) {\n    scriptDirectory = _scriptDir;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  if (scriptDirectory.indexOf('blob:') !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);\n  } else {\n    scriptDirectory = '';\n  }\n\n\n  read_ = function shell_read(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    readBinary = function readBinary(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n    };\n  }\n\n  readAsync = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n  setWindowTitle = function(title) { document.title = title };\n} else\n{\n}\n\n// Set up the out() and err() hooks, which are how we can print to stdout or\n// stderr, respectively.\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.warn.bind(console);\n\n// Merge back in the overrides\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = null;\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\nif (Module['arguments']) arguments_ = Module['arguments'];\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];\nif (Module['quit']) quit_ = Module['quit'];\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n\n// TODO remove when SDL2 is fixed (also see above)\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16;\n\n\nfunction dynamicAlloc(size) {\n  var ret = HEAP32[DYNAMICTOP_PTR>>2];\n  var end = (ret + size + 15) & -16;\n  if (end > _emscripten_get_heap_size()) {\n    abort();\n  }\n  HEAP32[DYNAMICTOP_PTR>>2] = end;\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n  return Math.ceil(size / factor) * factor;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': return 1;\n    case 'i16': return 2;\n    case 'i32': return 4;\n    case 'i64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length-1] === '*') {\n        return 4; // A pointer\n      } else if (type[0] === 'i') {\n        var bits = parseInt(type.substr(1));\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n        return bits / 8;\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    err(text);\n  }\n}\n\nvar asm2wasmImports = { // special asm2wasm imports\n    \"f64-rem\": function(x, y) {\n        return x % y;\n    },\n    \"debugger\": function() {\n    }\n};\n\n\n\nvar jsCallStartIndex = 1;\nvar functionPointers = new Array(0);\n\n// Wraps a JS function as a wasm function with a given signature.\n// In the future, we may get a WebAssembly.Function constructor. Until then,\n// we create a wasm module that takes the JS function as an import with a given\n// signature, and re-exports that as a wasm function.\nfunction convertJsFunctionToWasm(func, sig) {\n\n  // The module is static, with the exception of the type section, which is\n  // generated based on the signature passed in.\n  var typeSection = [\n    0x01, // id: section,\n    0x00, // length: 0 (placeholder)\n    0x01, // count: 1\n    0x60, // form: func\n  ];\n  var sigRet = sig.slice(0, 1);\n  var sigParam = sig.slice(1);\n  var typeCodes = {\n    'i': 0x7f, // i32\n    'j': 0x7e, // i64\n    'f': 0x7d, // f32\n    'd': 0x7c, // f64\n  };\n\n  // Parameters, length + signatures\n  typeSection.push(sigParam.length);\n  for (var i = 0; i < sigParam.length; ++i) {\n    typeSection.push(typeCodes[sigParam[i]]);\n  }\n\n  // Return values, length + signatures\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n  if (sigRet == 'v') {\n    typeSection.push(0x00);\n  } else {\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n  }\n\n  // Write the overall length of the type section back into the section header\n  // (excepting the 2 bytes for the section id and length)\n  typeSection[1] = typeSection.length - 2;\n\n  // Rest of the module is static\n  var bytes = new Uint8Array([\n    0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n    0x01, 0x00, 0x00, 0x00, // version: 1\n  ].concat(typeSection, [\n    0x02, 0x07, // import section\n      // (import \"e\" \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\n    0x07, 0x05, // export section\n      // (export \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x66, 0x00, 0x00,\n  ]));\n\n   // We can compile this wasm module synchronously because it is very small.\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n  var module = new WebAssembly.Module(bytes);\n  var instance = new WebAssembly.Instance(module, {\n    e: {\n      f: func\n    }\n  });\n  var wrappedFunc = instance.exports.f;\n  return wrappedFunc;\n}\n\n// Add a wasm function to the table.\nfunction addFunctionWasm(func, sig) {\n  var table = wasmTable;\n  var ret = table.length;\n\n  // Grow the table\n  try {\n    table.grow(1);\n  } catch (err) {\n    if (!err instanceof RangeError) {\n      throw err;\n    }\n    throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';\n  }\n\n  // Insert new element\n  try {\n    // Attempting to call this with JS function will cause of table.set() to fail\n    table.set(ret, func);\n  } catch (err) {\n    if (!err instanceof TypeError) {\n      throw err;\n    }\n    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');\n    var wrapped = convertJsFunctionToWasm(func, sig);\n    table.set(ret, wrapped);\n  }\n\n  return ret;\n}\n\nfunction removeFunctionWasm(index) {\n  // TODO(sbc): Look into implementing this to allow re-using of table slots\n}\n\n// 'sig' parameter is required for the llvm backend but only when func is not\n// already a WebAssembly function.\nfunction addFunction(func, sig) {\n\n\n  var base = 0;\n  for (var i = base; i < base + 0; i++) {\n    if (!functionPointers[i]) {\n      functionPointers[i] = func;\n      return jsCallStartIndex + i;\n    }\n  }\n  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n\n}\n\nfunction removeFunction(index) {\n\n  functionPointers[index-jsCallStartIndex] = null;\n}\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n  assert(sig);\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n  var sigCache = funcWrappers[sig];\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n  return sigCache[func];\n}\n\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = function(value) {\n  tempRet0 = value;\n};\n\nvar getTempRet0 = function() {\n  return tempRet0;\n};\n\n\nvar Runtime = {\n};\n\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\nvar GLOBAL_BASE = 1024;\n\n\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n\nvar wasmBinary;if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\nvar noExitRuntime;if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];\n\n\nif (typeof WebAssembly !== 'object') {\n  err('no native wasm support detected');\n}\n\n\n// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n/** @type {function(number, number, string, boolean=)} */\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n}\n\n/** @type {function(number, string, boolean=)} */\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for getValue: ' + type);\n    }\n  return null;\n}\n\n\n\n\n\n// Wasm globals\n\nvar wasmMemory;\n\n// In fastcomp asm.js, we don't need a wasm Table at all.\n// In the wasm backend, we polyfill the WebAssembly object,\n// so this creates a (non-native-wasm) table for us.\nvar wasmTable = new WebAssembly.Table({\n  'initial': 16192,\n  'maximum': 16192,\n  'element': 'anyfunc'\n});\n\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS = 0;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\n// C calling interface.\nfunction ccall(ident, returnType, argTypes, args, opts) {\n  // For fast lookup of conversion functions\n  var toC = {\n    'string': function(str) {\n      var ret = 0;\n      if (str !== null && str !== undefined && str !== 0) { // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        var len = (str.length << 2) + 1;\n        ret = stackAlloc(len);\n        stringToUTF8(str, ret, len);\n      }\n      return ret;\n    },\n    'array': function(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    }\n  };\n\n  function convertReturnValue(ret) {\n    if (returnType === 'string') return UTF8ToString(ret);\n    if (returnType === 'boolean') return Boolean(ret);\n    return ret;\n  }\n\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n\n  ret = convertReturnValue(ret);\n  if (stack !== 0) stackRestore(stack);\n  return ret;\n}\n\nfunction cwrap(ident, returnType, argTypes, opts) {\n  argTypes = argTypes || [];\n  // When the function takes numbers and returns a number, we can just return\n  // the original function\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\n  var numericRet = returnType !== 'string';\n  if (numericRet && numericArgs && !opts) {\n    return getCFunc(ident);\n  }\n  return function() {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  }\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 3; // Do not allocate\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [_malloc,\n    stackAlloc,\n    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[((ptr)>>2)]=0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[((ptr++)>>0)]=0;\n    }\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n\n  var i = 0, type, typeSize, previousType;\n  while (i < size) {\n    var curr = slab[i];\n\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret+i, curr, type);\n\n    // no need to look up size unless type changes, so cache it\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n\n  return ret;\n}\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n}\n\n\n\n\n/** @type {function(number, number=)} */\nfunction Pointer_stringify(ptr, length) {\n  abort(\"this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!\");\n}\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = HEAPU8[((ptr++)>>0)];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\n\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n/**\n * @param {number} idx\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n  while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var str = '';\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n    while (idx < endPtr) {\n      // For UTF8 byte structure, see:\n      // http://en.wikipedia.org/wiki/UTF-8#Description\n      // https://www.ietf.org/rfc/rfc2279.txt\n      // https://tools.ietf.org/html/rfc3629\n      var u0 = u8Array[idx++];\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n      var u1 = u8Array[idx++] & 63;\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n      var u2 = u8Array[idx++] & 63;\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);\n      }\n\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n      }\n    }\n  }\n  return str;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n// copy of that string as a Javascript String object.\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n//                 style or the other.\n/**\n * @param {number} ptr\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) ++len;\n    else if (u <= 0x7FF) len += 2;\n    else if (u <= 0xFFFF) len += 3;\n    else len += 4;\n  }\n  return len;\n}\n\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\nfunction UTF16ToString(ptr) {\n  var endPtr = ptr;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  var idx = endPtr >> 1;\n  while (HEAP16[idx]) ++idx;\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n\n    var str = '';\n    while (1) {\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n      if (codeUnit == 0) return str;\n      ++i;\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    HEAP16[((outPtr)>>1)]=codeUnit;\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP16[((outPtr)>>1)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\nfunction UTF32ToString(ptr) {\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n    if (utf32 == 0)\n      return str;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    HEAP32[((outPtr)>>2)]=codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP32[((outPtr)>>2)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n// Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = _malloc(size);\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Allocate stack space for a JS string, and write it there.\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\n}\n\n\n\n\n// Memory management\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - (x % multiple);\n  }\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\n  buffer,\n/** @type {Int8Array} */\n  HEAP8,\n/** @type {Uint8Array} */\n  HEAPU8,\n/** @type {Int16Array} */\n  HEAP16,\n/** @type {Uint16Array} */\n  HEAPU16,\n/** @type {Int32Array} */\n  HEAP32,\n/** @type {Uint32Array} */\n  HEAPU32,\n/** @type {Float32Array} */\n  HEAPF32,\n/** @type {Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n  buffer = buf;\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n}\n\n\nvar STATIC_BASE = 1024,\n    STACK_BASE = 87296,\n    STACKTOP = STACK_BASE,\n    STACK_MAX = 5330176,\n    DYNAMIC_BASE = 5330176,\n    DYNAMICTOP_PTR = 87088;\n\n\n\n\nvar TOTAL_STACK = 5242880;\n\nvar INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\n\n\n\n\n\n\n\n// In standalone mode, the wasm creates the memory, and the user can't provide it.\n// In non-standalone/normal mode, we create the memory here.\n\n// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm\n// memory is created in the wasm, not in JS.)\n\n  if (Module['wasmMemory']) {\n    wasmMemory = Module['wasmMemory'];\n  } else\n  {\n    wasmMemory = new WebAssembly.Memory({\n      'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n    });\n  }\n\n\nif (wasmMemory) {\n  buffer = wasmMemory.buffer;\n}\n\n// If the user provides an incorrect length, just use that length instead rather than providing the user to\n// specifically provide the memory length with Module['TOTAL_MEMORY'].\nINITIAL_TOTAL_MEMORY = buffer.byteLength;\nupdateGlobalBufferAndViews(buffer);\n\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\n\n\n\n\n\n\n\n\n\n\nfunction callRuntimeCallbacks(callbacks) {\n  while(callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  runtimeInitialized = true;\n  \n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  \n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  runtimeExited = true;\n}\n\nfunction postRun() {\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n                    : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n                        : Math.pow(2, bits-1);\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n  return value;\n}\n\n\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc;\n\n\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\nfunction getUniqueRunDependency(id) {\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  what += '';\n  out(what);\n  err(what);\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';\n}\n\n\nvar memoryInitializer = null;\n\n\n\n\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ?\n      filename.startsWith(dataURIPrefix) :\n      filename.indexOf(dataURIPrefix) === 0;\n}\n\n\n\n\nvar wasmBinaryFile = 'webm-wasm.wasm';\nif (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n}\n\nfunction getBinary() {\n  try {\n    if (wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n\n    if (readBinary) {\n      return readBinary(wasmBinaryFile);\n    } else {\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n  }\n  catch (err) {\n    abort(err);\n  }\n}\n\nfunction getBinaryPromise() {\n  // if we don't have the binary yet, and have the Fetch api, use that\n  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n      if (!response['ok']) {\n        throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n      }\n      return response['arrayBuffer']();\n    }).catch(function () {\n      return getBinary();\n    });\n  }\n  // Otherwise, getBinary should be able to get it synchronously\n  return new Promise(function(resolve, reject) {\n    resolve(getBinary());\n  });\n}\n\n\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  // prepare imports\n  var info = {\n    'env': asmLibraryArg,\n    'wasi_unstable': asmLibraryArg\n    ,\n    'global': {\n      'NaN': NaN,\n      'Infinity': Infinity\n    },\n    'global.Math': Math,\n    'asm2wasm': asm2wasmImports\n  };\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n    Module['asm'] = exports;\n    removeRunDependency('wasm-instantiate');\n  }\n   // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n  addRunDependency('wasm-instantiate');\n\n\n  function receiveInstantiatedSource(output) {\n    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n      // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n      // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n    receiveInstance(output['instance']);\n  }\n\n\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function(binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(receiver, function(reason) {\n      err('failed to asynchronously prepare wasm: ' + reason);\n      abort(reason);\n    });\n  }\n\n  // Prefer streaming instantiation if available.\n  function instantiateAsync() {\n    if (!wasmBinary &&\n        typeof WebAssembly.instantiateStreaming === 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch === 'function') {\n      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {\n        var result = WebAssembly.instantiateStreaming(response, info);\n        return result.then(receiveInstantiatedSource, function(reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err('wasm streaming compile failed: ' + reason);\n            err('falling back to ArrayBuffer instantiation');\n            instantiateArrayBuffer(receiveInstantiatedSource);\n          });\n      });\n    } else {\n      return instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n  }\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n  // to any other async startup actions they are performing.\n  if (Module['instantiateWasm']) {\n    try {\n      var exports = Module['instantiateWasm'](info, receiveInstance);\n      return exports;\n    } catch(e) {\n      err('Module.instantiateWasm callback failed with error: ' + e);\n      return false;\n    }\n  }\n\n  instantiateAsync();\n  return {}; // no exports yet; we'll fill them in later\n}\n\nModule['asm'] = createWasm;\n\n// Globals used by JS i64 conversions\nvar tempDouble;\nvar tempI64;\n\n// === Body ===\n\nvar ASM_CONSTS = [];\n\n\n\n\n\n// STATICTOP = STATIC_BASE + 86272;\n/* global initializers */  __ATINIT__.push({ func: function() { globalCtors() } });\n\n\n\n\n\n\n\n\n/* no memory initializer */\nvar tempDoublePtr = 87280\n\nfunction copyTempFloat(ptr) { // functions, because inlining this code increases code size too much\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n}\n\nfunction copyTempDouble(ptr) {\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];\n  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];\n  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];\n  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];\n}\n\n// {{PRE_LIBRARY}}\n\n\n  function demangle(func) {\n      return func;\n    }\n\n  function demangleAll(text) {\n      var regex =\n        /\\b__Z[\\w\\d_]+/g;\n      return text.replace(regex,\n        function(x) {\n          var y = demangle(x);\n          return x === y ? x : (y + ' [' + x + ']');\n        });\n    }\n\n  function jsStackTrace() {\n      var err = new Error();\n      if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error(0);\n        } catch(e) {\n          err = e;\n        }\n        if (!err.stack) {\n          return '(no stack trace available)';\n        }\n      }\n      return err.stack.toString();\n    }\n\n  function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    }\n\n  function ___cxa_allocate_exception(size) {\n      return _malloc(size);\n    }\n\n  \n  var ___exception_infos={};\n  \n  var ___exception_caught= [];\n  \n  function ___exception_addRef(ptr) {\n      if (!ptr) return;\n      var info = ___exception_infos[ptr];\n      info.refcount++;\n    }\n  \n  function ___exception_deAdjust(adjusted) {\n      if (!adjusted || ___exception_infos[adjusted]) return adjusted;\n      for (var key in ___exception_infos) {\n        var ptr = +key; // the iteration key is a string, and if we throw this, it must be an integer as that is what we look for\n        var adj = ___exception_infos[ptr].adjusted;\n        var len = adj.length;\n        for (var i = 0; i < len; i++) {\n          if (adj[i] === adjusted) {\n            return ptr;\n          }\n        }\n      }\n      return adjusted;\n    }function ___cxa_begin_catch(ptr) {\n      var info = ___exception_infos[ptr];\n      if (info && !info.caught) {\n        info.caught = true;\n        __ZSt18uncaught_exceptionv.uncaught_exceptions--;\n      }\n      if (info) info.rethrown = false;\n      ___exception_caught.push(ptr);\n      ___exception_addRef(___exception_deAdjust(ptr));\n      return ptr;\n    }\n\n  \n  var ___exception_last=0;function ___cxa_throw(ptr, type, destructor) {\n      ___exception_infos[ptr] = {\n        ptr: ptr,\n        adjusted: [ptr],\n        type: type,\n        destructor: destructor,\n        refcount: 0,\n        caught: false,\n        rethrown: false\n      };\n      ___exception_last = ptr;\n      if (!(\"uncaught_exception\" in __ZSt18uncaught_exceptionv)) {\n        __ZSt18uncaught_exceptionv.uncaught_exceptions = 1;\n      } else {\n        __ZSt18uncaught_exceptionv.uncaught_exceptions++;\n      }\n      throw ptr;\n    }\n\n  function ___gxx_personality_v0() {\n    }\n\n  function ___lock() {}\n\n  \n  function ___setErrNo(value) {\n      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;\n      return value;\n    }\n  \n  \n  var PATH={splitPath:function (filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },normalizeArray:function (parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },normalize:function (path) {\n        var isAbsolute = path.charAt(0) === '/',\n            trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter(function(p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },dirname:function (path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },basename:function (path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash+1);\n      },extname:function (path) {\n        return PATH.splitPath(path)[3];\n      },join:function () {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join('/'));\n      },join2:function (l, r) {\n        return PATH.normalize(l + '/' + r);\n      }};var SYSCALLS={buffers:[null,[],[]],printChar:function (stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },varargs:0,get:function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n        return ret;\n      },getStr:function () {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },get64:function () {\n        var low = SYSCALLS.get(), high = SYSCALLS.get();\n        return low;\n      },getZero:function () {\n        SYSCALLS.get();\n      }};function ___syscall221(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // fcntl64\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall5(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // open\n      var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get(); // optional TODO\n      var stream = FS.open(pathname, flags, mode);\n      return stream.fd;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // ioctl\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___unlock() {}\n\n  \n  function _fd_close(fd) {try {\n  \n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }function ___wasi_fd_close() {\n  return _fd_close.apply(null, arguments)\n  }\n\n  \n  function _fd_read(fd, iov, iovcnt, pnum) {try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n      HEAP32[((pnum)>>2)]=num\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }function ___wasi_fd_read() {\n  return _fd_read.apply(null, arguments)\n  }\n\n  \n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {try {\n  \n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }function ___wasi_fd_seek() {\n  return _fd_seek.apply(null, arguments)\n  }\n\n  \n  \n  function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      var fflush = Module[\"_fflush\"];\n      if (fflush) fflush(0);\n      var buffers = SYSCALLS.buffers;\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\n    }function _fd_write(fd, iov, iovcnt, pnum) {try {\n  \n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[(((iov)+(i*8))>>2)];\n        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n        for (var j = 0; j < len; j++) {\n          SYSCALLS.printChar(fd, HEAPU8[ptr+j]);\n        }\n        num += len;\n      }\n      HEAP32[((pnum)>>2)]=num\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }function ___wasi_fd_write() {\n  return _fd_write.apply(null, arguments)\n  }\n\n  \n  function getShiftFromSize(size) {\n      switch (size) {\n          case 1: return 0;\n          case 2: return 1;\n          case 4: return 2;\n          case 8: return 3;\n          default:\n              throw new TypeError('Unknown type size: ' + size);\n      }\n    }\n  \n  \n  \n  function embind_init_charCodes() {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n          codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    }var embind_charCodes=undefined;function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n      while (HEAPU8[c]) {\n          ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    }\n  \n  \n  var awaitingDependencies={};\n  \n  var registeredTypes={};\n  \n  var typeDependencies={};\n  \n  \n  \n  \n  \n  \n  var char_0=48;\n  \n  var char_9=57;function makeLegalFunctionName(name) {\n      if (undefined === name) {\n          return '_unknown';\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n          return '_' + name;\n      } else {\n          return name;\n      }\n    }function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      /*jshint evil:true*/\n      return new Function(\n          \"body\",\n          \"return function \" + name + \"() {\\n\" +\n          \"    \\\"use strict\\\";\" +\n          \"    return body.apply(this, arguments);\\n\" +\n          \"};\\n\"\n      )(body);\n    }function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function(message) {\n          this.name = errorName;\n          this.message = message;\n  \n          var stack = (new Error(message)).stack;\n          if (stack !== undefined) {\n              this.stack = this.toString() + '\\n' +\n                  stack.replace(/^Error(:[^\\n]*)?\\n/, '');\n          }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function() {\n          if (this.message === undefined) {\n              return this.name;\n          } else {\n              return this.name + ': ' + this.message;\n          }\n      };\n  \n      return errorClass;\n    }var BindingError=undefined;function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n  \n  \n  \n  var InternalError=undefined;function throwInternalError(message) {\n      throw new InternalError(message);\n    }function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n      myTypes.forEach(function(type) {\n          typeDependencies[type] = dependentTypes;\n      });\n  \n      function onComplete(typeConverters) {\n          var myTypeConverters = getTypeConverters(typeConverters);\n          if (myTypeConverters.length !== myTypes.length) {\n              throwInternalError('Mismatched type converter count');\n          }\n          for (var i = 0; i < myTypes.length; ++i) {\n              registerType(myTypes[i], myTypeConverters[i]);\n          }\n      }\n  \n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach(function(dt, i) {\n          if (registeredTypes.hasOwnProperty(dt)) {\n              typeConverters[i] = registeredTypes[dt];\n          } else {\n              unregisteredTypes.push(dt);\n              if (!awaitingDependencies.hasOwnProperty(dt)) {\n                  awaitingDependencies[dt] = [];\n              }\n              awaitingDependencies[dt].push(function() {\n                  typeConverters[i] = registeredTypes[dt];\n                  ++registered;\n                  if (registered === unregisteredTypes.length) {\n                      onComplete(typeConverters);\n                  }\n              });\n          }\n      });\n      if (0 === unregisteredTypes.length) {\n          onComplete(typeConverters);\n      }\n    }function registerType(rawType, registeredInstance, options) {\n      options = options || {};\n  \n      if (!('argPackAdvance' in registeredInstance)) {\n          throw new TypeError('registerType registeredInstance requires argPackAdvance');\n      }\n  \n      var name = registeredInstance.name;\n      if (!rawType) {\n          throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n          if (options.ignoreDuplicateRegistrations) {\n              return;\n          } else {\n              throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n          }\n      }\n  \n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n  \n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n          var callbacks = awaitingDependencies[rawType];\n          delete awaitingDependencies[rawType];\n          callbacks.forEach(function(cb) {\n              cb();\n          });\n      }\n    }function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n      var shift = getShiftFromSize(size);\n  \n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(wt) {\n              // ambiguous emscripten ABI: sometimes return values are\n              // true or false, and sometimes integers (0 or 1)\n              return !!wt;\n          },\n          'toWireType': function(destructors, o) {\n              return o ? trueValue : falseValue;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': function(pointer) {\n              // TODO: if heap is fixed (like in asm.js) this could be executed outside\n              var heap;\n              if (size === 1) {\n                  heap = HEAP8;\n              } else if (size === 2) {\n                  heap = HEAP16;\n              } else if (size === 4) {\n                  heap = HEAP32;\n              } else {\n                  throw new TypeError(\"Unknown boolean type size: \" + name);\n              }\n              return this['fromWireType'](heap[pointer >> shift]);\n          },\n          destructorFunction: null, // This type does not need a destructor\n      });\n    }\n\n  \n  \n  \n  function ClassHandle_isAliasOf(other) {\n      if (!(this instanceof ClassHandle)) {\n          return false;\n      }\n      if (!(other instanceof ClassHandle)) {\n          return false;\n      }\n  \n      var leftClass = this.$$.ptrType.registeredClass;\n      var left = this.$$.ptr;\n      var rightClass = other.$$.ptrType.registeredClass;\n      var right = other.$$.ptr;\n  \n      while (leftClass.baseClass) {\n          left = leftClass.upcast(left);\n          leftClass = leftClass.baseClass;\n      }\n  \n      while (rightClass.baseClass) {\n          right = rightClass.upcast(right);\n          rightClass = rightClass.baseClass;\n      }\n  \n      return leftClass === rightClass && left === right;\n    }\n  \n  \n  function shallowCopyInternalPointer(o) {\n      return {\n          count: o.count,\n          deleteScheduled: o.deleteScheduled,\n          preservePointerOnDelete: o.preservePointerOnDelete,\n          ptr: o.ptr,\n          ptrType: o.ptrType,\n          smartPtr: o.smartPtr,\n          smartPtrType: o.smartPtrType,\n      };\n    }\n  \n  function throwInstanceAlreadyDeleted(obj) {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\n    }\n  \n  \n  var finalizationGroup=false;\n  \n  function detachFinalizer(handle) {}\n  \n  \n  function runDestructor($$) {\n      if ($$.smartPtr) {\n          $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n          $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    }function releaseClassHandle($$) {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n      if (toDelete) {\n          runDestructor($$);\n      }\n    }function attachFinalizer(handle) {\n      if ('undefined' === typeof FinalizationGroup) {\n          attachFinalizer = function (handle) { return handle; };\n          return handle;\n      }\n      // If the running environment has a FinalizationGroup (see\n      // https://github.com/tc39/proposal-weakrefs), then attach finalizers\n      // for class handles.  We check for the presence of FinalizationGroup\n      // at run-time, not build-time.\n      finalizationGroup = new FinalizationGroup(function (iter) {\n          for (var result = iter.next(); !result.done; result = iter.next()) {\n              var $$ = result.value;\n              if (!$$.ptr) {\n                  console.warn('object already deleted: ' + $$.ptr);\n              } else {\n                  releaseClassHandle($$);\n              }\n          }\n      });\n      attachFinalizer = function(handle) {\n          finalizationGroup.register(handle, handle.$$, handle.$$);\n          return handle;\n      };\n      detachFinalizer = function(handle) {\n          finalizationGroup.unregister(handle.$$);\n      };\n      return attachFinalizer(handle);\n    }function ClassHandle_clone() {\n      if (!this.$$.ptr) {\n          throwInstanceAlreadyDeleted(this);\n      }\n  \n      if (this.$$.preservePointerOnDelete) {\n          this.$$.count.value += 1;\n          return this;\n      } else {\n          var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n              $$: {\n                  value: shallowCopyInternalPointer(this.$$),\n              }\n          }));\n  \n          clone.$$.count.value += 1;\n          clone.$$.deleteScheduled = false;\n          return clone;\n      }\n    }\n  \n  function ClassHandle_delete() {\n      if (!this.$$.ptr) {\n          throwInstanceAlreadyDeleted(this);\n      }\n  \n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n          throwBindingError('Object already scheduled for deletion');\n      }\n  \n      detachFinalizer(this);\n      releaseClassHandle(this.$$);\n  \n      if (!this.$$.preservePointerOnDelete) {\n          this.$$.smartPtr = undefined;\n          this.$$.ptr = undefined;\n      }\n    }\n  \n  function ClassHandle_isDeleted() {\n      return !this.$$.ptr;\n    }\n  \n  \n  var delayFunction=undefined;\n  \n  var deletionQueue=[];\n  \n  function flushPendingDeletes() {\n      while (deletionQueue.length) {\n          var obj = deletionQueue.pop();\n          obj.$$.deleteScheduled = false;\n          obj['delete']();\n      }\n    }function ClassHandle_deleteLater() {\n      if (!this.$$.ptr) {\n          throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n          throwBindingError('Object already scheduled for deletion');\n      }\n      deletionQueue.push(this);\n      if (deletionQueue.length === 1 && delayFunction) {\n          delayFunction(flushPendingDeletes);\n      }\n      this.$$.deleteScheduled = true;\n      return this;\n    }function init_ClassHandle() {\n      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;\n      ClassHandle.prototype['clone'] = ClassHandle_clone;\n      ClassHandle.prototype['delete'] = ClassHandle_delete;\n      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;\n      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;\n    }function ClassHandle() {\n    }\n  \n  var registeredPointers={};\n  \n  \n  function ensureOverloadTable(proto, methodName, humanName) {\n      if (undefined === proto[methodName].overloadTable) {\n          var prevFunc = proto[methodName];\n          // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\n          proto[methodName] = function() {\n              // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\n              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n                  throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n              }\n              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n          };\n          // Move the previous function into the overload table.\n          proto[methodName].overloadTable = [];\n          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n          if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {\n              throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n          }\n  \n          // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\n          // that routes between the two.\n          ensureOverloadTable(Module, name, name);\n          if (Module.hasOwnProperty(numArguments)) {\n              throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n          }\n          // Add the new function into the overload table.\n          Module[name].overloadTable[numArguments] = value;\n      }\n      else {\n          Module[name] = value;\n          if (undefined !== numArguments) {\n              Module[name].numArguments = numArguments;\n          }\n      }\n    }\n  \n  function RegisteredClass(\n      name,\n      constructor,\n      instancePrototype,\n      rawDestructor,\n      baseClass,\n      getActualType,\n      upcast,\n      downcast\n    ) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n  \n  \n  \n  function upcastPointer(ptr, ptrClass, desiredClass) {\n      while (ptrClass !== desiredClass) {\n          if (!ptrClass.upcast) {\n              throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n          }\n          ptr = ptrClass.upcast(ptr);\n          ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    }function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n          if (this.isReference) {\n              throwBindingError('null is not a valid ' + this.name);\n          }\n          return 0;\n      }\n  \n      if (!handle.$$) {\n          throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n  \n  function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n          if (this.isReference) {\n              throwBindingError('null is not a valid ' + this.name);\n          }\n  \n          if (this.isSmartPointer) {\n              ptr = this.rawConstructor();\n              if (destructors !== null) {\n                  destructors.push(this.rawDestructor, ptr);\n              }\n              return ptr;\n          } else {\n              return 0;\n          }\n      }\n  \n      if (!handle.$$) {\n          throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n          throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n  \n      if (this.isSmartPointer) {\n          // TODO: this is not strictly true\n          // We could support BY_EMVAL conversions from raw pointers to smart pointers\n          // because the smart pointer can hold a reference to the handle\n          if (undefined === handle.$$.smartPtr) {\n              throwBindingError('Passing raw pointer to smart pointer is illegal');\n          }\n  \n          switch (this.sharingPolicy) {\n              case 0: // NONE\n                  // no upcasting\n                  if (handle.$$.smartPtrType === this) {\n                      ptr = handle.$$.smartPtr;\n                  } else {\n                      throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\n                  }\n                  break;\n  \n              case 1: // INTRUSIVE\n                  ptr = handle.$$.smartPtr;\n                  break;\n  \n              case 2: // BY_EMVAL\n                  if (handle.$$.smartPtrType === this) {\n                      ptr = handle.$$.smartPtr;\n                  } else {\n                      var clonedHandle = handle['clone']();\n                      ptr = this.rawShare(\n                          ptr,\n                          __emval_register(function() {\n                              clonedHandle['delete']();\n                          })\n                      );\n                      if (destructors !== null) {\n                          destructors.push(this.rawDestructor, ptr);\n                      }\n                  }\n                  break;\n  \n              default:\n                  throwBindingError('Unsupporting sharing policy');\n          }\n      }\n      return ptr;\n    }\n  \n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n          if (this.isReference) {\n              throwBindingError('null is not a valid ' + this.name);\n          }\n          return 0;\n      }\n  \n      if (!handle.$$) {\n          throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\n      }\n      if (handle.$$.ptrType.isConst) {\n          throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n  \n  \n  function simpleReadValueFromPointer(pointer) {\n      return this['fromWireType'](HEAPU32[pointer >> 2]);\n    }\n  \n  function RegisteredPointer_getPointee(ptr) {\n      if (this.rawGetPointee) {\n          ptr = this.rawGetPointee(ptr);\n      }\n      return ptr;\n    }\n  \n  function RegisteredPointer_destructor(ptr) {\n      if (this.rawDestructor) {\n          this.rawDestructor(ptr);\n      }\n    }\n  \n  function RegisteredPointer_deleteObject(handle) {\n      if (handle !== null) {\n          handle['delete']();\n      }\n    }\n  \n  \n  function downcastPointer(ptr, ptrClass, desiredClass) {\n      if (ptrClass === desiredClass) {\n          return ptr;\n      }\n      if (undefined === desiredClass.baseClass) {\n          return null; // no conversion\n      }\n  \n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n          return null;\n      }\n      return desiredClass.downcast(rv);\n    }\n  \n  \n  \n  \n  function getInheritedInstanceCount() {\n      return Object.keys(registeredInstances).length;\n    }\n  \n  function getLiveInheritedInstances() {\n      var rv = [];\n      for (var k in registeredInstances) {\n          if (registeredInstances.hasOwnProperty(k)) {\n              rv.push(registeredInstances[k]);\n          }\n      }\n      return rv;\n    }\n  \n  function setDelayFunction(fn) {\n      delayFunction = fn;\n      if (deletionQueue.length && delayFunction) {\n          delayFunction(flushPendingDeletes);\n      }\n    }function init_embind() {\n      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;\n      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;\n      Module['flushPendingDeletes'] = flushPendingDeletes;\n      Module['setDelayFunction'] = setDelayFunction;\n    }var registeredInstances={};\n  \n  function getBasestPointer(class_, ptr) {\n      if (ptr === undefined) {\n          throwBindingError('ptr should not be undefined');\n      }\n      while (class_.baseClass) {\n          ptr = class_.upcast(ptr);\n          class_ = class_.baseClass;\n      }\n      return ptr;\n    }function getInheritedInstance(class_, ptr) {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    }\n  \n  function makeClassHandle(prototype, record) {\n      if (!record.ptrType || !record.ptr) {\n          throwInternalError('makeClassHandle requires ptr and ptrType');\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n          throwInternalError('Both smartPtrType and smartPtr must be specified');\n      }\n      record.count = { value: 1 };\n      return attachFinalizer(Object.create(prototype, {\n          $$: {\n              value: record,\n          },\n      }));\n    }function RegisteredPointer_fromWireType(ptr) {\n      // ptr is a raw pointer (or a raw smartpointer)\n  \n      // rawPointer is a maybe-null raw pointer\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n          this.destructor(ptr);\n          return null;\n      }\n  \n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (undefined !== registeredInstance) {\n          // JS object has been neutered, time to repopulate it\n          if (0 === registeredInstance.$$.count.value) {\n              registeredInstance.$$.ptr = rawPointer;\n              registeredInstance.$$.smartPtr = ptr;\n              return registeredInstance['clone']();\n          } else {\n              // else, just increment reference count on existing object\n              // it already has a reference to the smart pointer\n              var rv = registeredInstance['clone']();\n              this.destructor(ptr);\n              return rv;\n          }\n      }\n  \n      function makeDefaultHandle() {\n          if (this.isSmartPointer) {\n              return makeClassHandle(this.registeredClass.instancePrototype, {\n                  ptrType: this.pointeeType,\n                  ptr: rawPointer,\n                  smartPtrType: this,\n                  smartPtr: ptr,\n              });\n          } else {\n              return makeClassHandle(this.registeredClass.instancePrototype, {\n                  ptrType: this,\n                  ptr: ptr,\n              });\n          }\n      }\n  \n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n          return makeDefaultHandle.call(this);\n      }\n  \n      var toType;\n      if (this.isConst) {\n          toType = registeredPointerRecord.constPointerType;\n      } else {\n          toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(\n          rawPointer,\n          this.registeredClass,\n          toType.registeredClass);\n      if (dp === null) {\n          return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n          return makeClassHandle(toType.registeredClass.instancePrototype, {\n              ptrType: toType,\n              ptr: dp,\n              smartPtrType: this,\n              smartPtr: ptr,\n          });\n      } else {\n          return makeClassHandle(toType.registeredClass.instancePrototype, {\n              ptrType: toType,\n              ptr: dp,\n          });\n      }\n    }function init_RegisteredPointer() {\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n      RegisteredPointer.prototype['argPackAdvance'] = 8;\n      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;\n      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;\n      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;\n    }function RegisteredPointer(\n      name,\n      registeredClass,\n      isReference,\n      isConst,\n  \n      // smart pointer properties\n      isSmartPointer,\n      pointeeType,\n      sharingPolicy,\n      rawGetPointee,\n      rawConstructor,\n      rawShare,\n      rawDestructor\n    ) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n  \n      // smart pointer properties\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n  \n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n          if (isConst) {\n              this['toWireType'] = constNoSmartPtrRawPointerToWireType;\n              this.destructorFunction = null;\n          } else {\n              this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\n              this.destructorFunction = null;\n          }\n      } else {\n          this['toWireType'] = genericPointerToWireType;\n          // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns\n          // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.\n          // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in\n          //       craftInvokerFunction altogether.\n      }\n    }\n  \n  function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n          throwInternalError('Replacing nonexistant public symbol');\n      }\n      // If there's an overload table for this symbol, replace the symbol in the overload table instead.\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n          Module[name].overloadTable[numArguments] = value;\n      }\n      else {\n          Module[name] = value;\n          Module[name].argCount = numArguments;\n      }\n    }\n  \n  function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n  \n      function makeDynCaller(dynCall) {\n          var args = [];\n          for (var i = 1; i < signature.length; ++i) {\n              args.push('a' + i);\n          }\n  \n          var name = 'dynCall_' + signature + '_' + rawFunction;\n          var body = 'return function ' + name + '(' + args.join(', ') + ') {\\n';\n          body    += '    return dynCall(rawFunction' + (args.length ? ', ' : '') + args.join(', ') + ');\\n';\n          body    += '};\\n';\n  \n          return (new Function('dynCall', 'rawFunction', body))(dynCall, rawFunction);\n      }\n  \n      var fp;\n      if (Module['FUNCTION_TABLE_' + signature] !== undefined) {\n          fp = Module['FUNCTION_TABLE_' + signature][rawFunction];\n      } else if (typeof FUNCTION_TABLE !== \"undefined\") {\n          fp = FUNCTION_TABLE[rawFunction];\n      } else {\n          // asm.js does not give direct access to the function tables,\n          // and thus we must go through the dynCall interface which allows\n          // calling into a signature's function table by pointer value.\n          //\n          // https://github.com/dherman/asm.js/issues/83\n          //\n          // This has three main penalties:\n          // - dynCall is another function call in the path from JavaScript to C++.\n          // - JITs may not predict through the function table indirection at runtime.\n          var dc = Module['dynCall_' + signature];\n          if (dc === undefined) {\n              // We will always enter this branch if the signature\n              // contains 'f' and PRECISE_F32 is not enabled.\n              //\n              // Try again, replacing 'f' with 'd'.\n              dc = Module['dynCall_' + signature.replace(/f/g, 'd')];\n              if (dc === undefined) {\n                  throwBindingError(\"No dynCall invoker for signature: \" + signature);\n              }\n          }\n          fp = makeDynCaller(dc);\n      }\n  \n      if (typeof fp !== \"function\") {\n          throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n      }\n      return fp;\n    }\n  \n  \n  var UnboundTypeError=undefined;\n  \n  function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    }function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n          if (seen[type]) {\n              return;\n          }\n          if (registeredTypes[type]) {\n              return;\n          }\n          if (typeDependencies[type]) {\n              typeDependencies[type].forEach(visit);\n              return;\n          }\n          unboundTypes.push(type);\n          seen[type] = true;\n      }\n      types.forEach(visit);\n  \n      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));\n    }function __embind_register_class(\n      rawType,\n      rawPointerType,\n      rawConstPointerType,\n      baseClassRawType,\n      getActualTypeSignature,\n      getActualType,\n      upcastSignature,\n      upcast,\n      downcastSignature,\n      downcast,\n      name,\n      destructorSignature,\n      rawDestructor\n    ) {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      if (upcast) {\n          upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n      if (downcast) {\n          downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n  \n      exposePublicSymbol(legalFunctionName, function() {\n          // this code cannot run if baseClassRawType is zero\n          throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);\n      });\n  \n      whenDependentTypesAreResolved(\n          [rawType, rawPointerType, rawConstPointerType],\n          baseClassRawType ? [baseClassRawType] : [],\n          function(base) {\n              base = base[0];\n  \n              var baseClass;\n              var basePrototype;\n              if (baseClassRawType) {\n                  baseClass = base.registeredClass;\n                  basePrototype = baseClass.instancePrototype;\n              } else {\n                  basePrototype = ClassHandle.prototype;\n              }\n  \n              var constructor = createNamedFunction(legalFunctionName, function() {\n                  if (Object.getPrototypeOf(this) !== instancePrototype) {\n                      throw new BindingError(\"Use 'new' to construct \" + name);\n                  }\n                  if (undefined === registeredClass.constructor_body) {\n                      throw new BindingError(name + \" has no accessible constructor\");\n                  }\n                  var body = registeredClass.constructor_body[arguments.length];\n                  if (undefined === body) {\n                      throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n                  }\n                  return body.apply(this, arguments);\n              });\n  \n              var instancePrototype = Object.create(basePrototype, {\n                  constructor: { value: constructor },\n              });\n  \n              constructor.prototype = instancePrototype;\n  \n              var registeredClass = new RegisteredClass(\n                  name,\n                  constructor,\n                  instancePrototype,\n                  rawDestructor,\n                  baseClass,\n                  getActualType,\n                  upcast,\n                  downcast);\n  \n              var referenceConverter = new RegisteredPointer(\n                  name,\n                  registeredClass,\n                  true,\n                  false,\n                  false);\n  \n              var pointerConverter = new RegisteredPointer(\n                  name + '*',\n                  registeredClass,\n                  false,\n                  false,\n                  false);\n  \n              var constPointerConverter = new RegisteredPointer(\n                  name + ' const*',\n                  registeredClass,\n                  false,\n                  true,\n                  false);\n  \n              registeredPointers[rawType] = {\n                  pointerType: pointerConverter,\n                  constPointerType: constPointerConverter\n              };\n  \n              replacePublicSymbol(legalFunctionName, constructor);\n  \n              return [referenceConverter, pointerConverter, constPointerConverter];\n          }\n      );\n    }\n\n  \n  function heap32VectorToArray(count, firstElement) {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n          array.push(HEAP32[(firstElement >> 2) + i]);\n      }\n      return array;\n    }\n  \n  function runDestructors(destructors) {\n      while (destructors.length) {\n          var ptr = destructors.pop();\n          var del = destructors.pop();\n          del(ptr);\n      }\n    }function __embind_register_class_constructor(\n      rawClassType,\n      argCount,\n      rawArgTypesAddr,\n      invokerSignature,\n      invoker,\n      rawConstructor\n    ) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n  \n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\n          classType = classType[0];\n          var humanName = 'constructor ' + classType.name;\n  \n          if (undefined === classType.registeredClass.constructor_body) {\n              classType.registeredClass.constructor_body = [];\n          }\n          if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n              throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount-1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n          }\n          classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {\n              throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);\n          };\n  \n          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n              classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {\n                  if (arguments.length !== argCount - 1) {\n                      throwBindingError(humanName + ' called with ' + arguments.length + ' arguments, expected ' + (argCount-1));\n                  }\n                  var destructors = [];\n                  var args = new Array(argCount);\n                  args[0] = rawConstructor;\n                  for (var i = 1; i < argCount; ++i) {\n                      args[i] = argTypes[i]['toWireType'](destructors, arguments[i - 1]);\n                  }\n  \n                  var ptr = invoker.apply(null, args);\n                  runDestructors(destructors);\n  \n                  return argTypes[0]['fromWireType'](ptr);\n              };\n              return [];\n          });\n          return [];\n      });\n    }\n\n  \n  \n  function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n          throw new TypeError('new_ called with constructor type ' + typeof(constructor) + \" which is not a function\");\n      }\n  \n      /*\n       * Previously, the following line was just:\n  \n       function dummy() {};\n  \n       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even though at creation, the 'dummy' has the\n       * correct constructor name.  Thus, objects created with IMVU.new would show up in the debugger as 'dummy', which\n       * isn't very helpful.  Using IMVU.createNamedFunction addresses the issue.  Doublely-unfortunately, there's no way\n       * to write a test for this behavior.  -NRD 2013.02.22\n       */\n      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy;\n  \n      var r = constructor.apply(obj, argumentList);\n      return (r instanceof Object) ? r : obj;\n    }function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n      // humanName: a human-readable string name for the function to be generated.\n      // argTypes: An array that contains the embind type objects for all types in the function signature.\n      //    argTypes[0] is the type object for the function return value.\n      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\n      //    argTypes[2...] are the actual function parameters.\n      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\n      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\n      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\n      var argCount = argTypes.length;\n  \n      if (argCount < 2) {\n          throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n  \n      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);\n  \n      // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\n  // TODO: This omits argument count check - enable only at -O3 or similar.\n  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\n  //       return FUNCTION_TABLE[fn];\n  //    }\n  \n  \n      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\n      // TODO: Remove this completely once all function invokers are being dynamically generated.\n      var needsDestructorStack = false;\n  \n      for(var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.\n          if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack\n              needsDestructorStack = true;\n              break;\n          }\n      }\n  \n      var returns = (argTypes[0].name !== \"void\");\n  \n      var argsList = \"\";\n      var argsListWired = \"\";\n      for(var i = 0; i < argCount - 2; ++i) {\n          argsList += (i!==0?\", \":\"\")+\"arg\"+i;\n          argsListWired += (i!==0?\", \":\"\")+\"arg\"+i+\"Wired\";\n      }\n  \n      var invokerFnBody =\n          \"return function \"+makeLegalFunctionName(humanName)+\"(\"+argsList+\") {\\n\" +\n          \"if (arguments.length !== \"+(argCount - 2)+\") {\\n\" +\n              \"throwBindingError('function \"+humanName+\" called with ' + arguments.length + ' arguments, expected \"+(argCount - 2)+\" args!');\\n\" +\n          \"}\\n\";\n  \n  \n      if (needsDestructorStack) {\n          invokerFnBody +=\n              \"var destructors = [];\\n\";\n      }\n  \n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n  \n  \n      if (isClassMethodFunc) {\n          invokerFnBody += \"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\";\n      }\n  \n      for(var i = 0; i < argCount - 2; ++i) {\n          invokerFnBody += \"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";\n          args1.push(\"argType\"+i);\n          args2.push(argTypes[i+2]);\n      }\n  \n      if (isClassMethodFunc) {\n          argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n  \n      invokerFnBody +=\n          (returns?\"var rv = \":\"\") + \"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";\n  \n      if (needsDestructorStack) {\n          invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n          for(var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\n              var paramName = (i === 1 ? \"thisWired\" : (\"arg\"+(i - 2)+\"Wired\"));\n              if (argTypes[i].destructorFunction !== null) {\n                  invokerFnBody += paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";\n                  args1.push(paramName+\"_dtor\");\n                  args2.push(argTypes[i].destructorFunction);\n              }\n          }\n      }\n  \n      if (returns) {\n          invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" +\n                           \"return ret;\\n\";\n      } else {\n      }\n      invokerFnBody += \"}\\n\";\n  \n      args1.push(invokerFnBody);\n  \n      var invokerFunction = new_(Function, args1).apply(null, args2);\n      return invokerFunction;\n    }function __embind_register_class_function(\n      rawClassType,\n      methodName,\n      argCount,\n      rawArgTypesAddr, // [ReturnType, ThisType, Args...]\n      invokerSignature,\n      rawInvoker,\n      context,\n      isPureVirtual\n    ) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n  \n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\n          classType = classType[0];\n          var humanName = classType.name + '.' + methodName;\n  \n          if (isPureVirtual) {\n              classType.registeredClass.pureVirtualFunctions.push(methodName);\n          }\n  \n          function unboundTypesHandler() {\n              throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);\n          }\n  \n          var proto = classType.registeredClass.instancePrototype;\n          var method = proto[methodName];\n          if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {\n              // This is the first overload to be registered, OR we are replacing a function in the base class with a function in the derived class.\n              unboundTypesHandler.argCount = argCount - 2;\n              unboundTypesHandler.className = classType.name;\n              proto[methodName] = unboundTypesHandler;\n          } else {\n              // There was an existing function with the same name registered. Set up a function overload routing table.\n              ensureOverloadTable(proto, methodName, humanName);\n              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n          }\n  \n          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n  \n              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n  \n              // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types\n              // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.\n              if (undefined === proto[methodName].overloadTable) {\n                  // Set argCount in case an overload is registered later\n                  memberFunction.argCount = argCount - 2;\n                  proto[methodName] = memberFunction;\n              } else {\n                  proto[methodName].overloadTable[argCount - 2] = memberFunction;\n              }\n  \n              return [];\n          });\n          return [];\n      });\n    }\n\n  \n  \n  var emval_free_list=[];\n  \n  var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle) {\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n          emval_handle_array[handle] = undefined;\n          emval_free_list.push(handle);\n      }\n    }\n  \n  \n  \n  function count_emval_handles() {\n      var count = 0;\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n          if (emval_handle_array[i] !== undefined) {\n              ++count;\n          }\n      }\n      return count;\n    }\n  \n  function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n          if (emval_handle_array[i] !== undefined) {\n              return emval_handle_array[i];\n          }\n      }\n      return null;\n    }function init_emval() {\n      Module['count_emval_handles'] = count_emval_handles;\n      Module['get_first_emval'] = get_first_emval;\n    }function __emval_register(value) {\n  \n      switch(value){\n        case undefined :{ return 1; }\n        case null :{ return 2; }\n        case true :{ return 3; }\n        case false :{ return 4; }\n        default:{\n          var handle = emval_free_list.length ?\n              emval_free_list.pop() :\n              emval_handle_array.length;\n  \n          emval_handle_array[handle] = {refcount: 1, value: value};\n          return handle;\n          }\n        }\n    }function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(handle) {\n              var rv = emval_handle_array[handle].value;\n              __emval_decref(handle);\n              return rv;\n          },\n          'toWireType': function(destructors, value) {\n              return __emval_register(value);\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': simpleReadValueFromPointer,\n          destructorFunction: null, // This type does not need a destructor\n  \n          // TODO: do we need a deleteObject here?  write a test where\n          // emval is passed into JS via an interface\n      });\n    }\n\n  \n  function _embind_repr(v) {\n      if (v === null) {\n          return 'null';\n      }\n      var t = typeof v;\n      if (t === 'object' || t === 'array' || t === 'function') {\n          return v.toString();\n      } else {\n          return '' + v;\n      }\n    }\n  \n  function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n          case 2: return function(pointer) {\n              return this['fromWireType'](HEAPF32[pointer >> 2]);\n          };\n          case 3: return function(pointer) {\n              return this['fromWireType'](HEAPF64[pointer >> 3]);\n          };\n          default:\n              throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(value) {\n              return value;\n          },\n          'toWireType': function(destructors, value) {\n              // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations: we could\n              // avoid the following if() and assume value is of proper type.\n              if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n                  throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n              }\n              return value;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': floatReadValueFromPointer(name, shift),\n          destructorFunction: null, // This type does not need a destructor\n      });\n    }\n\n  \n  function integerReadValueFromPointer(name, shift, signed) {\n      // integers are quite common, so generate very specialized functions\n      switch (shift) {\n          case 0: return signed ?\n              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :\n              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };\n          case 1: return signed ?\n              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :\n              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };\n          case 2: return signed ?\n              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :\n              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };\n          default:\n              throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      name = readLatin1String(name);\n      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.\n          maxRange = 4294967295;\n      }\n  \n      var shift = getShiftFromSize(size);\n  \n      var fromWireType = function(value) {\n          return value;\n      };\n  \n      if (minRange === 0) {\n          var bitshift = 32 - 8*size;\n          fromWireType = function(value) {\n              return (value << bitshift) >>> bitshift;\n          };\n      }\n  \n      var isUnsignedType = (name.indexOf('unsigned') != -1);\n  \n      registerType(primitiveType, {\n          name: name,\n          'fromWireType': fromWireType,\n          'toWireType': function(destructors, value) {\n              // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations: we could\n              // avoid the following two if()s and assume value is of proper type.\n              if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n                  throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n              }\n              if (value < minRange || value > maxRange) {\n                  throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + ', ' + maxRange + ']!');\n              }\n              return isUnsignedType ? (value >>> 0) : (value | 0);\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),\n          destructorFunction: null, // This type does not need a destructor\n      });\n    }\n\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [\n          Int8Array,\n          Uint8Array,\n          Int16Array,\n          Uint16Array,\n          Int32Array,\n          Uint32Array,\n          Float32Array,\n          Float64Array,\n      ];\n  \n      var TA = typeMapping[dataTypeIndex];\n  \n      function decodeMemoryView(handle) {\n          handle = handle >> 2;\n          var heap = HEAPU32;\n          var size = heap[handle]; // in elements\n          var data = heap[handle + 1]; // byte offset into emscripten heap\n          return new TA(heap['buffer'], data, size);\n      }\n  \n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': decodeMemoryView,\n          'argPackAdvance': 8,\n          'readValueFromPointer': decodeMemoryView,\n      }, {\n          ignoreDuplicateRegistrations: true,\n      });\n    }\n\n  function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      var stdStringIsUTF8\n      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>\n      = (name === \"std::string\");\n  \n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(value) {\n              var length = HEAPU32[value >> 2];\n  \n              var str;\n              if(stdStringIsUTF8) {\n                  //ensure null termination at one-past-end byte if not present yet\n                  var endChar = HEAPU8[value + 4 + length];\n                  var endCharSwap = 0;\n                  if(endChar != 0)\n                  {\n                    endCharSwap = endChar;\n                    HEAPU8[value + 4 + length] = 0;\n                  }\n  \n                  var decodeStartPtr = value + 4;\n                  //looping here to support possible embedded '0' bytes\n                  for (var i = 0; i <= length; ++i) {\n                    var currentBytePtr = value + 4 + i;\n                    if(HEAPU8[currentBytePtr] == 0)\n                    {\n                      var stringSegment = UTF8ToString(decodeStartPtr);\n                      if(str === undefined)\n                        str = stringSegment;\n                      else\n                      {\n                        str += String.fromCharCode(0);\n                        str += stringSegment;\n                      }\n                      decodeStartPtr = currentBytePtr + 1;\n                    }\n                  }\n  \n                  if(endCharSwap != 0)\n                    HEAPU8[value + 4 + length] = endCharSwap;\n              } else {\n                  var a = new Array(length);\n                  for (var i = 0; i < length; ++i) {\n                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n                  }\n                  str = a.join('');\n              }\n  \n              _free(value);\n              \n              return str;\n          },\n          'toWireType': function(destructors, value) {\n              if (value instanceof ArrayBuffer) {\n                  value = new Uint8Array(value);\n              }\n              \n              var getLength;\n              var valueIsOfTypeString = (typeof value === 'string');\n  \n              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n                  throwBindingError('Cannot pass non-string to std::string');\n              }\n              if (stdStringIsUTF8 && valueIsOfTypeString) {\n                  getLength = function() {return lengthBytesUTF8(value);};\n              } else {\n                  getLength = function() {return value.length;};\n              }\n              \n              // assumes 4-byte alignment\n              var length = getLength();\n              var ptr = _malloc(4 + length + 1);\n              HEAPU32[ptr >> 2] = length;\n  \n              if (stdStringIsUTF8 && valueIsOfTypeString) {\n                  stringToUTF8(value, ptr + 4, length + 1);\n              } else {\n                  if(valueIsOfTypeString) {\n                      for (var i = 0; i < length; ++i) {\n                          var charCode = value.charCodeAt(i);\n                          if (charCode > 255) {\n                              _free(ptr);\n                              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\n                          }\n                          HEAPU8[ptr + 4 + i] = charCode;\n                      }\n                  } else {\n                      for (var i = 0; i < length; ++i) {\n                          HEAPU8[ptr + 4 + i] = value[i];\n                      }\n                  }\n              }\n  \n              if (destructors !== null) {\n                  destructors.push(_free, ptr);\n              }\n              return ptr;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': simpleReadValueFromPointer,\n          destructorFunction: function(ptr) { _free(ptr); },\n      });\n    }\n\n  function __embind_register_std_wstring(rawType, charSize, name) {\n      // nb. do not cache HEAPU16 and HEAPU32, they may be destroyed by emscripten_resize_heap().\n      name = readLatin1String(name);\n      var getHeap, shift;\n      if (charSize === 2) {\n          getHeap = function() { return HEAPU16; };\n          shift = 1;\n      } else if (charSize === 4) {\n          getHeap = function() { return HEAPU32; };\n          shift = 2;\n      }\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(value) {\n              var HEAP = getHeap();\n              var length = HEAPU32[value >> 2];\n              var a = new Array(length);\n              var start = (value + 4) >> shift;\n              for (var i = 0; i < length; ++i) {\n                  a[i] = String.fromCharCode(HEAP[start + i]);\n              }\n              _free(value);\n              return a.join('');\n          },\n          'toWireType': function(destructors, value) {\n              // assumes 4-byte alignment\n              var length = value.length;\n              var ptr = _malloc(4 + length * charSize);\n              var HEAP = getHeap();\n              HEAPU32[ptr >> 2] = length;\n              var start = (ptr + 4) >> shift;\n              for (var i = 0; i < length; ++i) {\n                  HEAP[start + i] = value.charCodeAt(i);\n              }\n              if (destructors !== null) {\n                  destructors.push(_free, ptr);\n              }\n              return ptr;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': simpleReadValueFromPointer,\n          destructorFunction: function(ptr) { _free(ptr); },\n      });\n    }\n\n  function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n          isVoid: true, // void return values can be optimized out sometimes\n          name: name,\n          'argPackAdvance': 0,\n          'fromWireType': function() {\n              return undefined;\n          },\n          'toWireType': function(destructors, o) {\n              // TODO: assert if anything else is given?\n              return undefined;\n          },\n      });\n    }\n\n  \n  \n  function requireRegisteredType(rawType, humanName) {\n      var impl = registeredTypes[rawType];\n      if (undefined === impl) {\n          throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n      }\n      return impl;\n    }function __emval_lookupTypes(argCount, argTypes, argWireTypes) {\n      var a = new Array(argCount);\n      for (var i = 0; i < argCount; ++i) {\n          a[i] = requireRegisteredType(\n              HEAP32[(argTypes >> 2) + i],\n              \"parameter \" + i);\n      }\n      return a;\n    }\n  \n  function requireHandle(handle) {\n      if (!handle) {\n          throwBindingError('Cannot use deleted val. handle = ' + handle);\n      }\n      return emval_handle_array[handle].value;\n    }function __emval_call(handle, argCount, argTypes, argv) {\n      handle = requireHandle(handle);\n      var types = __emval_lookupTypes(argCount, argTypes);\n  \n      var args = new Array(argCount);\n      for (var i = 0; i < argCount; ++i) {\n          var type = types[i];\n          args[i] = type['readValueFromPointer'](argv);\n          argv += type['argPackAdvance'];\n      }\n  \n      var rv = handle.apply(undefined, args);\n      return __emval_register(rv);\n    }\n\n\n  function __emval_incref(handle) {\n      if (handle > 4) {\n          emval_handle_array[handle].refcount += 1;\n      }\n    }\n\n  function __emval_take_value(type, argv) {\n      type = requireRegisteredType(type, '_emval_take_value');\n      var v = type['readValueFromPointer'](argv);\n      return __emval_register(v);\n    }\n\n  function _abort() {\n      abort();\n    }\n\n  function _emscripten_get_heap_size() {\n      return HEAP8.length;\n    }\n\n   \n\n  \n  function abortOnCannotGrowMemory(requestedSize) {\n      abort('OOM');\n    }\n  \n  function emscripten_realloc_buffer(size) {\n      try {\n        // round size grow request up to wasm page size (fixed 64KB per spec)\n        wasmMemory.grow((size - buffer.byteLength + 65535) >> 16); // .grow() takes a delta compared to the previous size\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1 /*success*/;\n      } catch(e) {\n      }\n    }function _emscripten_resize_heap(requestedSize) {\n      var oldSize = _emscripten_get_heap_size();\n      // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.\n  \n  \n      var PAGE_MULTIPLE = 65536;\n      var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.\n  \n      if (requestedSize > LIMIT) {\n        return false;\n      }\n  \n      var MIN_TOTAL_MEMORY = 16777216;\n      var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.\n  \n      // TODO: see realloc_buffer - for PTHREADS we may want to decrease these jumps\n      while (newSize < requestedSize) { // Keep incrementing the heap size as long as it's less than what is requested.\n        if (newSize <= 536870912) {\n          newSize = alignUp(2 * newSize, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...\n        } else {\n          // ..., but after that, add smaller increments towards 2GB, which we cannot reach\n          newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);\n        }\n  \n      }\n  \n  \n  \n      var replacement = emscripten_realloc_buffer(newSize);\n      if (!replacement) {\n        return false;\n      }\n  \n  \n  \n      return true;\n    }\n\n  function _gettimeofday(ptr) {\n      var now = Date.now();\n      HEAP32[((ptr)>>2)]=(now/1000)|0; // seconds\n      HEAP32[(((ptr)+(4))>>2)]=((now % 1000)*1000)|0; // microseconds\n      return 0;\n    }\n\n  \n  function _llvm_log10_f32(x) {\n      return Math.log(x) / Math.LN10; // TODO: Math.log10, when browser support is there\n    }function _llvm_log10_f64(a0\n  /*``*/) {\n  return _llvm_log10_f32(a0);\n  }\n\n  \n   \n\n  function _llvm_trap() {\n      abort('trap!');\n    }\n\n  \n   \n  \n   \n  \n   function _longjmp(env, value) {\n      _setThrew(env, value || 1);\n      throw 'longjmp';\n    }\n\n  \n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n    }\n  \n   \n\n   \n\n   \n\n  function _pthread_cond_destroy() { return 0; }\n\n  function _pthread_cond_init() { return 0; }\n\n  function _pthread_create() {\n      return 6;\n    }\n\n  function _pthread_join() {}\n\n\n\n  function _time(ptr) {\n      var ret = (Date.now()/1000)|0;\n      if (ptr) {\n        HEAP32[((ptr)>>2)]=ret;\n      }\n      return ret;\n    }\nembind_init_charCodes();\nBindingError = Module['BindingError'] = extendError(Error, 'BindingError');;\nInternalError = Module['InternalError'] = extendError(Error, 'InternalError');;\ninit_ClassHandle();\ninit_RegisteredPointer();\ninit_embind();;\nUnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;\ninit_emval();;\nvar ASSERTIONS = false;\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\n\n\n// ASM_LIBRARY EXTERN PRIMITIVES: Math_floor,Math_ceil,Int8Array,Int32Array\n\n\nfunction invoke_dd(index,a1) {\n  var sp = stackSave();\n  try {\n    return dynCall_dd(index,a1);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_i(index) {\n  var sp = stackSave();\n  try {\n    return dynCall_i(index);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_ii(index,a1) {\n  var sp = stackSave();\n  try {\n    return dynCall_ii(index,a1);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iii(index,a1,a2) {\n  var sp = stackSave();\n  try {\n    return dynCall_iii(index,a1,a2);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {\n  var sp = stackSave();\n  try {\n    return dynCall_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiijj(index,a1,a2,a3,a4,a5,a6,a7) {\n  var sp = stackSave();\n  try {\n    return dynCall_iiiijj(index,a1,a2,a3,a4,a5,a6,a7);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_vi(index,a1) {\n  var sp = stackSave();\n  try {\n    dynCall_vi(index,a1);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_vii(index,a1,a2) {\n  var sp = stackSave();\n  try {\n    dynCall_vii(index,a1,a2);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viii(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    dynCall_viii(index,a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viiii(index,a1,a2,a3,a4) {\n  var sp = stackSave();\n  try {\n    dynCall_viiii(index,a1,a2,a3,a4);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viiiii(index,a1,a2,a3,a4,a5) {\n  var sp = stackSave();\n  try {\n    dynCall_viiiii(index,a1,a2,a3,a4,a5);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0 && e !== 'longjmp') throw e;\n    _setThrew(1, 0);\n  }\n}\n\nvar asmGlobalArg = {};\n\nvar asmLibraryArg = { \"ClassHandle\": ClassHandle, \"ClassHandle_clone\": ClassHandle_clone, \"ClassHandle_delete\": ClassHandle_delete, \"ClassHandle_deleteLater\": ClassHandle_deleteLater, \"ClassHandle_isAliasOf\": ClassHandle_isAliasOf, \"ClassHandle_isDeleted\": ClassHandle_isDeleted, \"RegisteredClass\": RegisteredClass, \"RegisteredPointer\": RegisteredPointer, \"RegisteredPointer_deleteObject\": RegisteredPointer_deleteObject, \"RegisteredPointer_destructor\": RegisteredPointer_destructor, \"RegisteredPointer_fromWireType\": RegisteredPointer_fromWireType, \"RegisteredPointer_getPointee\": RegisteredPointer_getPointee, \"___cxa_allocate_exception\": ___cxa_allocate_exception, \"___cxa_begin_catch\": ___cxa_begin_catch, \"___cxa_throw\": ___cxa_throw, \"___exception_addRef\": ___exception_addRef, \"___exception_deAdjust\": ___exception_deAdjust, \"___gxx_personality_v0\": ___gxx_personality_v0, \"___lock\": ___lock, \"___setErrNo\": ___setErrNo, \"___syscall221\": ___syscall221, \"___syscall5\": ___syscall5, \"___syscall54\": ___syscall54, \"___unlock\": ___unlock, \"___wasi_fd_close\": ___wasi_fd_close, \"___wasi_fd_read\": ___wasi_fd_read, \"___wasi_fd_seek\": ___wasi_fd_seek, \"___wasi_fd_write\": ___wasi_fd_write, \"__embind_register_bool\": __embind_register_bool, \"__embind_register_class\": __embind_register_class, \"__embind_register_class_constructor\": __embind_register_class_constructor, \"__embind_register_class_function\": __embind_register_class_function, \"__embind_register_emval\": __embind_register_emval, \"__embind_register_float\": __embind_register_float, \"__embind_register_integer\": __embind_register_integer, \"__embind_register_memory_view\": __embind_register_memory_view, \"__embind_register_std_string\": __embind_register_std_string, \"__embind_register_std_wstring\": __embind_register_std_wstring, \"__embind_register_void\": __embind_register_void, \"__emval_call\": __emval_call, \"__emval_decref\": __emval_decref, \"__emval_incref\": __emval_incref, \"__emval_lookupTypes\": __emval_lookupTypes, \"__emval_register\": __emval_register, \"__emval_take_value\": __emval_take_value, \"__memory_base\": 1024, \"__table_base\": 0, \"_abort\": _abort, \"_embind_repr\": _embind_repr, \"_emscripten_get_heap_size\": _emscripten_get_heap_size, \"_emscripten_memcpy_big\": _emscripten_memcpy_big, \"_emscripten_resize_heap\": _emscripten_resize_heap, \"_fd_close\": _fd_close, \"_fd_read\": _fd_read, \"_fd_seek\": _fd_seek, \"_fd_write\": _fd_write, \"_gettimeofday\": _gettimeofday, \"_llvm_log10_f32\": _llvm_log10_f32, \"_llvm_log10_f64\": _llvm_log10_f64, \"_llvm_trap\": _llvm_trap, \"_longjmp\": _longjmp, \"_pthread_cond_destroy\": _pthread_cond_destroy, \"_pthread_cond_init\": _pthread_cond_init, \"_pthread_create\": _pthread_create, \"_pthread_join\": _pthread_join, \"_time\": _time, \"abort\": abort, \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory, \"attachFinalizer\": attachFinalizer, \"constNoSmartPtrRawPointerToWireType\": constNoSmartPtrRawPointerToWireType, \"count_emval_handles\": count_emval_handles, \"craftInvokerFunction\": craftInvokerFunction, \"createNamedFunction\": createNamedFunction, \"demangle\": demangle, \"demangleAll\": demangleAll, \"detachFinalizer\": detachFinalizer, \"downcastPointer\": downcastPointer, \"embind__requireFunction\": embind__requireFunction, \"embind_init_charCodes\": embind_init_charCodes, \"emscripten_realloc_buffer\": emscripten_realloc_buffer, \"ensureOverloadTable\": ensureOverloadTable, \"exposePublicSymbol\": exposePublicSymbol, \"extendError\": extendError, \"floatReadValueFromPointer\": floatReadValueFromPointer, \"flushPendingDeletes\": flushPendingDeletes, \"flush_NO_FILESYSTEM\": flush_NO_FILESYSTEM, \"genericPointerToWireType\": genericPointerToWireType, \"getBasestPointer\": getBasestPointer, \"getInheritedInstance\": getInheritedInstance, \"getInheritedInstanceCount\": getInheritedInstanceCount, \"getLiveInheritedInstances\": getLiveInheritedInstances, \"getShiftFromSize\": getShiftFromSize, \"getTempRet0\": getTempRet0, \"getTypeName\": getTypeName, \"get_first_emval\": get_first_emval, \"heap32VectorToArray\": heap32VectorToArray, \"init_ClassHandle\": init_ClassHandle, \"init_RegisteredPointer\": init_RegisteredPointer, \"init_embind\": init_embind, \"init_emval\": init_emval, \"integerReadValueFromPointer\": integerReadValueFromPointer, \"invoke_dd\": invoke_dd, \"invoke_i\": invoke_i, \"invoke_ii\": invoke_ii, \"invoke_iii\": invoke_iii, \"invoke_iiiiiiiii\": invoke_iiiiiiiii, \"invoke_iiiijj\": invoke_iiiijj, \"invoke_vi\": invoke_vi, \"invoke_vii\": invoke_vii, \"invoke_viii\": invoke_viii, \"invoke_viiii\": invoke_viiii, \"invoke_viiiii\": invoke_viiiii, \"jsStackTrace\": jsStackTrace, \"makeClassHandle\": makeClassHandle, \"makeLegalFunctionName\": makeLegalFunctionName, \"memory\": wasmMemory, \"new_\": new_, \"nonConstNoSmartPtrRawPointerToWireType\": nonConstNoSmartPtrRawPointerToWireType, \"readLatin1String\": readLatin1String, \"registerType\": registerType, \"releaseClassHandle\": releaseClassHandle, \"replacePublicSymbol\": replacePublicSymbol, \"requireHandle\": requireHandle, \"requireRegisteredType\": requireRegisteredType, \"runDestructor\": runDestructor, \"runDestructors\": runDestructors, \"setDelayFunction\": setDelayFunction, \"setTempRet0\": setTempRet0, \"shallowCopyInternalPointer\": shallowCopyInternalPointer, \"simpleReadValueFromPointer\": simpleReadValueFromPointer, \"stackTrace\": stackTrace, \"table\": wasmTable, \"tempDoublePtr\": tempDoublePtr, \"throwBindingError\": throwBindingError, \"throwInstanceAlreadyDeleted\": throwInstanceAlreadyDeleted, \"throwInternalError\": throwInternalError, \"throwUnboundTypeError\": throwUnboundTypeError, \"upcastPointer\": upcastPointer, \"whenDependentTypesAreResolved\": whenDependentTypesAreResolved };\n// EMSCRIPTEN_START_ASM\nvar asm =Module[\"asm\"]// EMSCRIPTEN_END_ASM\n(asmGlobalArg, asmLibraryArg, buffer);\n\nModule[\"asm\"] = asm;\nvar __ZSt18uncaught_exceptionv = Module[\"__ZSt18uncaught_exceptionv\"] = function() {\n  return Module[\"asm\"][\"__ZSt18uncaught_exceptionv\"].apply(null, arguments)\n};\n\nvar ___cxa_can_catch = Module[\"___cxa_can_catch\"] = function() {\n  return Module[\"asm\"][\"___cxa_can_catch\"].apply(null, arguments)\n};\n\nvar ___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = function() {\n  return Module[\"asm\"][\"___cxa_is_pointer_type\"].apply(null, arguments)\n};\n\nvar ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function() {\n  return Module[\"asm\"][\"___embind_register_native_and_builtin_types\"].apply(null, arguments)\n};\n\nvar ___getTypeName = Module[\"___getTypeName\"] = function() {\n  return Module[\"asm\"][\"___getTypeName\"].apply(null, arguments)\n};\n\nvar _emscripten_get_sbrk_ptr = Module[\"_emscripten_get_sbrk_ptr\"] = function() {\n  return Module[\"asm\"][\"_emscripten_get_sbrk_ptr\"].apply(null, arguments)\n};\n\nvar _emscripten_replace_memory = Module[\"_emscripten_replace_memory\"] = function() {\n  return Module[\"asm\"][\"_emscripten_replace_memory\"].apply(null, arguments)\n};\n\nvar _free = Module[\"_free\"] = function() {\n  return Module[\"asm\"][\"_free\"].apply(null, arguments)\n};\n\nvar _llvm_round_f64 = Module[\"_llvm_round_f64\"] = function() {\n  return Module[\"asm\"][\"_llvm_round_f64\"].apply(null, arguments)\n};\n\nvar _malloc = Module[\"_malloc\"] = function() {\n  return Module[\"asm\"][\"_malloc\"].apply(null, arguments)\n};\n\nvar _memcpy = Module[\"_memcpy\"] = function() {\n  return Module[\"asm\"][\"_memcpy\"].apply(null, arguments)\n};\n\nvar _memmove = Module[\"_memmove\"] = function() {\n  return Module[\"asm\"][\"_memmove\"].apply(null, arguments)\n};\n\nvar _memset = Module[\"_memset\"] = function() {\n  return Module[\"asm\"][\"_memset\"].apply(null, arguments)\n};\n\nvar _realloc = Module[\"_realloc\"] = function() {\n  return Module[\"asm\"][\"_realloc\"].apply(null, arguments)\n};\n\nvar _saveSetjmp = Module[\"_saveSetjmp\"] = function() {\n  return Module[\"asm\"][\"_saveSetjmp\"].apply(null, arguments)\n};\n\nvar _setThrew = Module[\"_setThrew\"] = function() {\n  return Module[\"asm\"][\"_setThrew\"].apply(null, arguments)\n};\n\nvar _testSetjmp = Module[\"_testSetjmp\"] = function() {\n  return Module[\"asm\"][\"_testSetjmp\"].apply(null, arguments)\n};\n\nvar establishStackSpace = Module[\"establishStackSpace\"] = function() {\n  return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments)\n};\n\nvar globalCtors = Module[\"globalCtors\"] = function() {\n  return Module[\"asm\"][\"globalCtors\"].apply(null, arguments)\n};\n\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\n  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments)\n};\n\nvar stackRestore = Module[\"stackRestore\"] = function() {\n  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments)\n};\n\nvar stackSave = Module[\"stackSave\"] = function() {\n  return Module[\"asm\"][\"stackSave\"].apply(null, arguments)\n};\n\nvar dynCall_dd = Module[\"dynCall_dd\"] = function() {\n  return Module[\"asm\"][\"dynCall_dd\"].apply(null, arguments)\n};\n\nvar dynCall_i = Module[\"dynCall_i\"] = function() {\n  return Module[\"asm\"][\"dynCall_i\"].apply(null, arguments)\n};\n\nvar dynCall_ii = Module[\"dynCall_ii\"] = function() {\n  return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments)\n};\n\nvar dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iii = Module[\"dynCall_iii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iii\"].apply(null, arguments)\n};\n\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiii = Module[\"dynCall_iiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiiii = Module[\"dynCall_iiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiiiiii = Module[\"dynCall_iiiiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiiiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiiiiiii = Module[\"dynCall_iiiiiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiiiiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiiiiiiii = Module[\"dynCall_iiiiiiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiiiiiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiiiiiiiii = Module[\"dynCall_iiiiiiiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiiiiiiiiii = Module[\"dynCall_iiiiiiiiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiiiiiiiiiiiiiiii = Module[\"dynCall_iiiiiiiiiiiiiiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiiiiiiiiiiiiiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiijj = Module[\"dynCall_iiiijj\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiiijj\"].apply(null, arguments)\n};\n\nvar dynCall_iiijiii = Module[\"dynCall_iiijiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_iiijiii\"].apply(null, arguments)\n};\n\nvar dynCall_iij = Module[\"dynCall_iij\"] = function() {\n  return Module[\"asm\"][\"dynCall_iij\"].apply(null, arguments)\n};\n\nvar dynCall_ji = Module[\"dynCall_ji\"] = function() {\n  return Module[\"asm\"][\"dynCall_ji\"].apply(null, arguments)\n};\n\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\n  return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments)\n};\n\nvar dynCall_v = Module[\"dynCall_v\"] = function() {\n  return Module[\"asm\"][\"dynCall_v\"].apply(null, arguments)\n};\n\nvar dynCall_vi = Module[\"dynCall_vi\"] = function() {\n  return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments)\n};\n\nvar dynCall_vii = Module[\"dynCall_vii\"] = function() {\n  return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments)\n};\n\nvar dynCall_viii = Module[\"dynCall_viii\"] = function() {\n  return Module[\"asm\"][\"dynCall_viii\"].apply(null, arguments)\n};\n\nvar dynCall_viiii = Module[\"dynCall_viiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_viiii\"].apply(null, arguments)\n};\n\nvar dynCall_viiiii = Module[\"dynCall_viiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_viiiii\"].apply(null, arguments)\n};\n\nvar dynCall_viiiiii = Module[\"dynCall_viiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_viiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_viiiiiii = Module[\"dynCall_viiiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_viiiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_viiiiiiiiiii = Module[\"dynCall_viiiiiiiiiii\"] = function() {\n  return Module[\"asm\"][\"dynCall_viiiiiiiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_vijj = Module[\"dynCall_vijj\"] = function() {\n  return Module[\"asm\"][\"dynCall_vijj\"].apply(null, arguments)\n};\n;\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule['asm'] = asm;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar calledRun;\n\n// Modularize mode returns a function, which can be called to\n// create instances. The instances provide a then() method,\n// must like a Promise, that receives a callback. The callback\n// is called when the module is ready to run, with the module\n// as a parameter. (Like a Promise, it also returns the module\n// so you can use the output of .then(..)).\nModule['then'] = function(func) {\n  // We may already be ready to run code at this time. if\n  // so, just queue a call to the callback.\n  if (calledRun) {\n    func(Module);\n  } else {\n    // we are not ready to call then() yet. we must call it\n    // at the same time we would call onRuntimeInitialized.\n    var old = Module['onRuntimeInitialized'];\n    Module['onRuntimeInitialized'] = function() {\n      if (old) old();\n      func(Module);\n    };\n  }\n  return Module;\n};\n\n/**\n * @constructor\n * @this {ExitStatus}\n */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n}\n\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\n\n\n\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || arguments_;\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n\n  preRun();\n\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    preMain();\n\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n}\nModule['run'] = run;\n\n\nfunction exit(status, implicit) {\n\n  // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n  if (implicit && noExitRuntime && status === 0) {\n    return;\n  }\n\n  if (noExitRuntime) {\n  } else {\n\n    ABORT = true;\n    EXITSTATUS = status;\n\n    exitRuntime();\n\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  quit_(status, new ExitStatus(status));\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\n\n  noExitRuntime = true;\n\nrun();\n\n\n\n\n\n// {{MODULE_ADDITIONS}}\n\n\n\n\n\n  return Module\n}\n);\n})();\nexport default Module;","/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport webmWasm from \"../../dist/webm-wasm.js\";\n\n// Below you find the Interop between Node and Web is fun section.\n// On the web you can communicate with the main thread via `self`.\n// In node land you need to get the `parentPort` from the `worker_threads`\n// module.\nlet parentPort;\ntry {\n  ({ parentPort } = require(\"worker_threads\"));\n} catch (_) {\n  parentPort = self;\n}\n\n// On the web you get a `MessageEvent` which has the message payload on\n// its `.data` property.\n// In node land the event is the message payload itself.\nfunction onMessage(target, f) {\n  if (\"on\" in target) {\n    return target.on(\"message\", f);\n  }\n  return target.addEventListener(\"message\", e => f(e.data));\n}\n\nfunction nextMessage(target) {\n  return new Promise(resolve => {\n    if (\"once\" in target) {\n      return target.once(\"message\", resolve);\n    }\n    return target.addEventListener(\"message\", e => resolve(e.data), {\n      once: true\n    });\n  });\n}\n\nfunction initWasmModule(moduleFactory, wasmUrl) {\n  return new Promise(resolve => {\n    const module = moduleFactory({\n      // Just to be safe, don't automatically invoke any wasm functions\n      noInitialRun: true,\n      locateFile(url) {\n        if (url.endsWith(\".wasm\")) {\n          return wasmUrl;\n        }\n        return url;\n      },\n      onRuntimeInitialized() {\n        // An Emscripten is a then-able that resolves with itself, causing an infite loop when you\n        // wrap it in a real promise. Delete the `then` prop solves this for now.\n        // https://github.com/kripken/emscripten/issues/5820\n        delete module.then;\n        resolve(module);\n      }\n    });\n  });\n}\n\nimport defaultConfig from \"./defaults.js\";\n\nasync function init() {\n  const wasmPath = await nextMessage(parentPort, \"message\");\n  const module = await initWasmModule(webmWasm, wasmPath);\n  parentPort.postMessage(\"READY\");\n  const userParams = await nextMessage(parentPort, \"message\");\n  const params = Object.assign({}, defaultConfig, userParams);\n  if(!('kLive' in params)) {\n    params.kLive = params.realtime;\n  }\n  const instance = new module.WebmEncoder(\n    params.timebaseNum,\n    params.timebaseDen,\n    params.width,\n    params.height,\n    params.bitrate,\n    params.realtime,\n    params.kLive,\n    params.lossless,\n    params.speed,\n    chunk => {\n      const copy = new Uint8Array(chunk);\n      parentPort.postMessage(copy.buffer, [copy.buffer]);\n    }\n  );\n  onMessage(parentPort, msg => {\n    // A false-y message indicates the end-of-stream.\n    if (!msg) {\n      // This will invoke the callback to flush\n      instance.finalize();\n      // Signal the end-of-stream\n      parentPort.postMessage(null);\n      // Free up the memory.\n      instance.delete();\n      return;\n    }\n    instance.addRGBAFrame(msg);\n  });\n}\ninit();\n","/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport default {\n  width: 300,\n  height: 150,\n  timebaseNum: 1,\n  timebaseDen: 30,\n  bitrate: 200,\n  realtime: false,\n  lossless: 1,\n  speed: 9\n};\n"],"names":["_scriptDir","parentPort","Module","key","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_SHELL","moduleOverrides","hasOwnProperty","window","importScripts","process","versions","node","read_","readBinary","nodeFS","nodePath","scriptDirectory","__dirname","filename","binary","ret","require","toString","buffer","Uint8Array","assert","length","replace","slice","ex","ExitStatus","abort","read","f","data","readbuffer","scriptArgs","print","console","log","warn","error","printErr","self","location","href","document","currentScript","src","indexOf","substr","lastIndexOf","url","xhr","XMLHttpRequest","open","send","responseText","responseType","response","out","bind","err","wasmBinary","wasmMemory","asm2wasmImports","f64-rem","x","y","debugger","tempRet0","Array","WebAssembly","wasmTable","Table","initial","maximum","element","ABORT","condition","text","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","UTF8Decoder","TextDecoder","undefined","UTF8ArrayToString","u8Array","idx","maxBytesToRead","endIdx","endPtr","subarray","decode","str","u0","u1","u2","String","fromCharCode","ch","UTF8ToString","ptr","alignUp","multiple","updateGlobalBufferAndViews","buf","Int8Array","Int16Array","Int32Array","Uint16Array","Uint32Array","Float32Array","Float64Array","STATIC_BASE","INITIAL_TOTAL_MEMORY","callRuntimeCallbacks","callbacks","callback","shift","func","arg","Memory","byteLength","DYNAMICTOP_PTR","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATPOSTRUN__","runDependencies","dependenciesFulfilled","what","isDataURI","prototype","startsWith","path","wasmBinaryFile","getBinary","demangleAll","jsStackTrace","Error","stack","e","info","env","asmLibraryArg","wasi_unstable","global","NaN","Infinity","global.Math","Math","asm2wasm","receiveInstance","instance","module","exports","id","removeRunDependency","receiveInstantiatedSource","output","instantiateArrayBuffer","receiver","fetch","Promise","resolve","reject","credentials","then","instantiate","reason","instantiateStreaming","instantiateAsync","push","globalCtors","___exception_infos","___exception_addRef","refcount","___exception_deAdjust","adjusted","adj","len","i","SYSCALLS","buffers","printChar","stream","curr","varargs","get","getStr","get64","low","getZero","_fd_close","fd","FS","ErrnoError","errno","_fd_read","iov","iovcnt","pnum","getStreamFromFD","num","doReadv","_fd_seek","offset_low","offset_high","whence","newOffset","_fd_write","j","getShiftFromSize","size","TypeError","embind_init_charCodes","codes","embind_charCodes","readLatin1String","c","awaitingDependencies","registeredTypes","typeDependencies","makeLegalFunctionName","name","charCodeAt","createNamedFunction","body","Function","extendError","baseErrorType","errorName","errorClass","message","this","Object","create","constructor","BindingError","throwBindingError","InternalError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","forEach","type","unregisteredTypes","registered","dt","rawType","registeredInstance","options","ignoreDuplicateRegistrations","cb","ClassHandle_isAliasOf","other","ClassHandle","leftClass","$$","ptrType","registeredClass","left","rightClass","right","baseClass","upcast","shallowCopyInternalPointer","o","count","deleteScheduled","preservePointerOnDelete","smartPtr","smartPtrType","throwInstanceAlreadyDeleted","obj","finalizationGroup","detachFinalizer","handle","runDestructor","rawDestructor","releaseClassHandle","value","attachFinalizer","FinalizationGroup","iter","result","next","done","unregister","register","ClassHandle_clone","clone","getPrototypeOf","ClassHandle_delete","ClassHandle_isDeleted","delayFunction","deletionQueue","flushPendingDeletes","pop","ClassHandle_deleteLater","init_ClassHandle","registeredPointers","ensureOverloadTable","proto","methodName","humanName","overloadTable","prevFunc","arguments","apply","argCount","exposePublicSymbol","numArguments","RegisteredClass","instancePrototype","getActualType","downcast","pureVirtualFunctions","upcastPointer","ptrClass","desiredClass","constNoSmartPtrRawPointerToWireType","destructors","isReference","_embind_repr","genericPointerToWireType","isSmartPointer","rawConstructor","isConst","sharingPolicy","clonedHandle","rawShare","__emval_register","nonConstNoSmartPtrRawPointerToWireType","simpleReadValueFromPointer","pointer","RegisteredPointer_getPointee","rawGetPointee","RegisteredPointer_destructor","RegisteredPointer_deleteObject","downcastPointer","rv","getInheritedInstanceCount","keys","registeredInstances","getLiveInheritedInstances","k","setDelayFunction","fn","init_embind","getBasestPointer","class_","getInheritedInstance","makeClassHandle","record","RegisteredPointer_fromWireType","rawPointer","getPointee","destructor","makeDefaultHandle","pointeeType","toType","actualType","registeredPointerRecord","call","dp","constPointerType","pointerType","init_RegisteredPointer","RegisteredPointer","destructorFunction","replacePublicSymbol","embind__requireFunction","signature","rawFunction","fp","FUNCTION_TABLE","dc","dynCall","args","join","makeDynCaller","UnboundTypeError","getTypeName","___getTypeName","_free","throwUnboundTypeError","types","unboundTypes","seen","visit","map","heap32VectorToArray","firstElement","array","runDestructors","del","new_","argumentList","dummy","r","craftInvokerFunction","argTypes","classType","cppInvokerFunc","cppTargetFunc","isClassMethodFunc","needsDestructorStack","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","emval_free_list","emval_handle_array","__emval_decref","count_emval_handles","get_first_emval","init_emval","v","t","floatReadValueFromPointer","integerReadValueFromPointer","signed","requireRegisteredType","impl","__emval_lookupTypes","argWireTypes","a","requireHandle","_emscripten_get_heap_size","emscripten_realloc_buffer","grow","_llvm_log10_f32","LN10","___cxa_allocate_exception","_malloc","___cxa_begin_catch","caught","__ZSt18uncaught_exceptionv","uncaught_exceptions","rethrown","___cxa_throw","___gxx_personality_v0","___lock","___setErrNo","___syscall221","which","___syscall5","pathname","flags","mode","___syscall54","___unlock","___wasi_fd_close","___wasi_fd_read","___wasi_fd_seek","___wasi_fd_write","__embind_register_bool","trueValue","falseValue","fromWireType","wt","toWireType","argPackAdvance","readValueFromPointer","heap","__embind_register_class","rawPointerType","rawConstPointerType","baseClassRawType","getActualTypeSignature","upcastSignature","downcastSignature","destructorSignature","legalFunctionName","base","basePrototype","constructor_body","referenceConverter","pointerConverter","constPointerConverter","__embind_register_class_constructor","rawClassType","rawArgTypesAddr","invokerSignature","invoker","rawArgTypes","__embind_register_class_function","rawInvoker","context","isPureVirtual","unboundTypesHandler","method","className","memberFunction","__embind_register_emval","__embind_register_float","__embind_register_integer","primitiveType","minRange","maxRange","bitshift","isUnsignedType","__embind_register_memory_view","dataTypeIndex","TA","decodeMemoryView","__embind_register_std_string","stdStringIsUTF8","endChar","endCharSwap","decodeStartPtr","currentBytePtr","stringSegment","ArrayBuffer","valueIsOfTypeString","Uint8ClampedArray","u","lengthBytesUTF8","outU8Array","outIdx","maxBytesToWrite","stringToUTF8Array","charCode","__embind_register_std_wstring","charSize","getHeap","HEAP","start","__embind_register_void","isVoid","__emval_call","argv","__emval_incref","__emval_take_value","__memory_base","__table_base","_abort","_emscripten_memcpy_big","dest","set","_emscripten_resize_heap","requestedSize","oldSize","newSize","max","min","_gettimeofday","now","Date","_llvm_log10_f64","a0","_llvm_trap","_longjmp","_setThrew","_pthread_cond_destroy","_pthread_cond_init","_pthread_create","_pthread_join","_time","abortOnCannotGrowMemory","demangle","flush_NO_FILESYSTEM","fflush","getTempRet0","invoke_dd","index","a1","sp","stackSave","dynCall_dd","stackRestore","invoke_i","dynCall_i","invoke_ii","dynCall_ii","invoke_iii","a2","dynCall_iii","invoke_iiiiiiiii","a3","a4","a5","a6","a7","a8","dynCall_iiiiiiiii","invoke_iiiijj","dynCall_iiiijj","invoke_vi","dynCall_vi","invoke_vii","dynCall_vii","invoke_viii","dynCall_viii","invoke_viiii","dynCall_viiii","invoke_viiiii","dynCall_viiiii","memory","setTempRet0","stackTrace","js","table","tempDoublePtr","asm","calledRun","status","run","doRun","unshift","postRun","preRun","setTimeout","old","runCaller","width","height","timebaseNum","timebaseDen","bitrate","realtime","lossless","speed","_","nextMessage","target","once","addEventListener","wasmPath","moduleFactory","webmWasm","wasmUrl","noInitialRun","locateFile","endsWith","onRuntimeInitialized","postMessage","userParams","params","assign","defaultConfig","kLive","WebmEncoder","chunk","copy","on","onMessage","msg","finalize","addRGBAFrame","init"],"mappings":"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"}